\section{Конструкторская часть}

В данном разделе описываются используемые структуры данных, проводится
подробное описание алгоритма оптимизации динамической трансляции доступа к памяти и сопутствующих ему алгоритмов. Проводится проектирование программной реализации алгоритма оптимизации динамической трансляции доступа к памяти.

Алгоритм рассчитан на организацию кода в блоки из которых одна точка выхода в конце блока и одна точка входа --- в начале блока.

\subsection{Архитектура программного обеспечения}

ну вообще не обязательно ?

или обязательно...... 

\subsection{Используемые структуры данных}

$BlockInfo$ --- структура хранящая информацию об отдельном блоке транслированного кода. Включает в себя:

\begin{itemize}[leftmargin=1.6\parindent]
	\item[---] $State$ --- рассчитанное состояние блока, свидетельствует о состоянии регистра RBP, либо регистр не менялся, либо в нем адрес связанный со стеком, либо в нем адрес не связанный со стеком.
	\item[---] $StackNodes$ --- множество операций загружающих стековое значение;
	\item[---] $UnStackNodes$ --- множество операций загружающих не стековое значение;
	\item[---] $Predecessors$ --- множество блоков трансляции предшествующих этому;
	\item[---] $Visited$ --- флаг, показывает обработан ли блок.
\end{itemize}


\begin{comment}
{
	+  int State = NOT_CHANGED;
	+  std::set<OrderedNode*> StackNodes;
	+  std::set<OrderedNode*> UnStackNodes;
	+  std::vector<OrderedNode*> Predecessors;
	+  // std::vector<OrderedNode*> Successors;
	+  bool Visited = false;
	+};
+
\end{comment}

\subsection{Алгоритм оптимизации динамической трансляции доступа к памяти}

\textbf{Входные данные:} Множество блоков транслированного кода $IRBlocks$.

\textbf{Выходные данные:} Множество блоков транслированного кода $IRBlocks$ с оптимизированным доступом к памяти.

\begin{algorithm}[H]
\small
	\caption{Алгоритм оптимизации динамической трансляции доступа к памяти}
	\label{alg:memopt}
	\begin{algorithmic}[1]
		\State $in$ $\gets$ множество блоков транслированного кода
		\State $out$ $\gets$ множество блоков транслированного кода с оптимизированным доступом к памяти
		\State $ControlFlow$ $\gets$ построить граф потока выполнения блоков
		\For{$i$ in $in$}
		\State $StackStatus$ $\gets$ STACK
		\For{$j$ in предшевственники $i$}
		\State $PredecessorState$ $\gets$ рассчитать состояние блока с учетом предшественников
		\If {$CodeNode$ $\neq$ STACK}
		\State $StackStatus$ $\gets$ $PredecessorState$
		\EndIf
		\EndFor
		\For{$CodeNode$ in строки кода $i$}
		\If {$CodeNode$ = инструкция загрузки адреса стека в RBP}
		\State $StackStatus$ $\gets$ STACK
		\EndIf
		\If {$CodeNode$ = инструкция загрузки любого значения, кроме стека в RBP}
		\State $StackStatus$ $\gets$ NOT\_STACK
		\EndIf
		\If {$StackStatus$ == STACK \textbf{and} $CodeNode$ = инструкция записи или чтения по адресу регистра RBP}
		\State $out$ $\gets$ заменить барьерную инструкцию на обычную
		\EndIf
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}


\subsection{Алгоритм построения графа выполнения блоков}

\begin{algorithm}[H]
\small
	\caption{Алгоритм построения графа выполнения блоков}
	\label{alg:graph}
	\begin{algorithmic}[1]
		\State $in$ $\gets$ множество блоков транслированного кода
		\State $Predecessors$ $\gets$ ориентированный граф потока выполнения блоков
		\State $State$ $\gets$ множество состояний блоков
		\State $StackNodes$ $\gets$ множество строк изменяющих содержимое регистра RBP на значение связанное с RSP
		\State $UnStackNodes$ $\gets$ множество строк изменяющих содержимое регистра RBP на значение не связанное с RSP
		\For{$i$ in $in$}
		\For{$j$ in строки $i$}
		\If {$j$ --- условный переход}
		\State $Predecessors$ $\gets$ i --- предшественник блоков куда передается управление
		\EndIf
		\If {$j$ --- безусловный переход}
		\State $Predecessors$ $\gets$ i --- предшественник блока куда передается управление
		\EndIf
		\If {$j$ --- запись регистра RBP}
		\If {записывается связанное с RSP значение}
		\State $State$ $\gets$ в блоке стековое значение
		\State $StackNodes$ $\gets$ строка записи стекового значения
		\Else
		\State $State$ $\gets$ в блоке не стековое значение
		\State $UnStackNodes$ $\gets$ строка записи не стекового значения
		\EndIf
		\EndIf
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

\subsection{Алгоритм распространения состояния регистра}

Этот алгоритм используется для определения состояния регистра в последующих блоках. Если в блоке 1 была произведена загрузка стекового значения в регистр RBP, а в блоке 2, для которого предок только блок 1, этот регистр не меняется, то для всех потомков блока 2 следует считать что регистр содержит стековое значение.

\begin{algorithm}[H]
\small
	\caption{Алгоритм распространения состояния стека}
	\label{alg:bilin}
	\begin{algorithmic}[1]
		\State $in$ $\gets$ множество блоков транслированного кода
		\State $out$ $\gets$ множество блоков транслированного кода с оптимизированным доступом к памяти
		\State $ControlFlow$ $\gets$ рассчитать порядок выполнения блоков
		\For{$i$ in $in$}
		\State $StackStatus$ $\gets$ STACK
		\For{$j$ in предшевственники $i$}
		\State $PredecessorState$ $\gets$ рассчитать состояние блока с учетом предшественников
		\If {$CodeNode$ $\neq$ STACK}
		\State $StackStatus$ $\gets$ $PredecessorState$
		\EndIf
		\EndFor
		\For{$CodeNode$ in строки кода $i$}
		\If {$CodeNode$ = инструкция загрузки адреса стека в RBP}
		\State $StackStatus$ $\gets$ STACK
		\EndIf
		\If {$CodeNode$ = инструкция загрузки любого значения, кроме стека в RBP}
		\State $StackStatus$ $\gets$ NOT\_STACK
		\EndIf
		\If {$StackStatus$ == STACK \textbf{and} $CodeNode$ = инструкция записи или чтения по адресу регистра RBP}
		\State $out$ $\gets$ заменить барьерную инструкцию на обычную
		\EndIf
		\EndFor
		\EndFor
	\end{algorithmic}
\end{algorithm}

\subsection{Вывод}

Были описаны используемые структуры данных, дано описание алгоритмов используемых.. Был спроектирован алгоритм оптимизации динамической трансляции доступа к памяти.?

\pagebreak