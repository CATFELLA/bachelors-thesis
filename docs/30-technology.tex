\section{Технологическая часть}

В данном разделе описываются средства разработки программного обеспечения, требования к вычислительной системе. Приводится структура разработанного приложения.

\subsection{Выбор средств разработки}

Из рассмотренных в аналитическом разделе трансляторов FEX лучше прочих подходит для реализации алгоритма, так как в нем присутствует СЕП.

\subsubsection{Выбор языка программирования}

Динамический транслятор FEX написан на языке C++, в нем используются разные библиотеки, например ядро транслятора FEXCore это библиотека реализующая непосредственно динамическую трансляцию. FEXCore также написан на C++ и не предусматривает расширений с помощью внешних модулей, поэтому для того чтобы ее модифицировать надо писать код на C++.

\subsubsection{Сборка программного обеспечения}

Для сборки проекта используется система сборки
CMake. Для компиляции реализации алгоритма необходимо добавить имя файла в соответствующий CMakeLists.txt.

Для сборки всего проекта используется ninja (а почему (желательно написать)). На листинге \ref{code:args} указана конфигурация сборки проекта.

\begin{code}
	\captionof{listing}{Конфигурация сборки проекта}
	\label{code:args}
	\begin{minted}
		[
		frame=single,
		framerule=0.5pt,
		framesep=20pt,
		fontsize=\small,
		tabsize=4,
		linenos,
		numbersep=5pt,
		xleftmargin=10pt,
		]
		{text}
CC=clang CXX=clang++ cmake -DCMAKE_INSTALL_PREFIX=/usr \
-DCMAKE_BUILD_TYPE=Release -DENABLE_LTO=True \
-DBUILD_TESTS=False -DCMAKE_CXX_COMPILER_LAUNCHER=ccache \
-DENABLE_CLANG_FORMAT=False -G Ninja ..
	\end{minted}
\end{code}

Оптимизирующий проход создан на основе версии 2204, коммит \\ 37f1e55ed5dc7a35ba9bf875e250de0b75581a22.

дерево зависимостей fex (cmake -> make -> graphwiz)

че за симейк какие цели используются

\subsection{Требования к вычислительной системе}

Для запуска программного обеспечения требуется исходный код динамического транслятора FEX. Так как алгоритм реализует оптимизацию доступа к памяти с сохранением корректного выполнения многопоточных приложений для прироста в скорости требуется процессор с поддерживаемой архитектурой со слабым доступом к памяти и несколькими ядрами, то есть оптимизирующий проход будет приводить к росту производительности не только на ARM, но и, например, RISC-V.

Для разработки и сборки проекта использовался ноутбук на основе процессора RK3399, архитектуры ARM.

полученный фех ехе запускать на арме, но можно разрабатывать его и кросс компайлом (типа среда выполнения требует арм, а среда разработки нет). можно попробовать расписать как скросс компилировать

можно попробовать mtune

\subsection{Структура программного обеспечения}

Разработанное ПО реализовано как оптимизирующий проход над промежуточным представлением.

При инициализации транслятора вызывается функция AddDefaultPasses, внутри которой вызываются функции InsertPass регистрирующие оптимизирующие проходы в определенном порядке. Функция InsertPass принимает на вход std::unique\_ptr<Pass> --- указатель на экземпляр класса прохода. У класса обязательно должен быть метод Run принимающий на вход IREmitter и возвращающий bool --- был ли изменен код во время прохода.

вывести tree над папкой

запихнуть патч

написать про tst-cond16

ls патч, инсталлер и ридми

\subsection{Распространение программного обеспечения}

Программное обеспечение распространяется в виде патча сформированного командой git format-patch. Для применения патча к проекту можно, например, использовать git am.

\subsection{more?}

а написать про дампы + скрипт для дампов, объясняю как проблемы решал?
так я узнал вот что превращаются TSO инструкции

проверить генерятся ли доки (ключ)

ключ отключения всех оптимизаций

\subsection{как контрибьютить}

Ведущими разработчиками являются такие то, чтобы пропихнуть патч надо то-то. Требуется одобрение такого то.

\subsection{Вывод}

В данном разделе были описаны средства разработки программного
обеспечения, требования к вычислительной системе. Была дана структура
разработанного приложения.

\pagebreak