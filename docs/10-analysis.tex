\section{Аналитическая часть}

Проблемы эмулятора:
\begin{itemize}[leftmargin=1.6\parindent]
	\item[---] управление кэшем транслированного кода;
	\item[---] выделение регистров;
	\item[---] оптимизация условных блоков;
	\item[---] direct block chaining????? lmao;
	\item[---] управление памятью;
	\item[---] поддержка самоизменяемого кода;
	\item[---] поддержка исключений;
	\item[---] поддержка аппаратных прерываний;
	\item[---] эмуляция режима пользователя.
\end{itemize}

\subsection{QEMU}

(инфа 2005 года...)
В QEMU реализована динамическая трансляция инструкций. QEMU транслирует команды при помощи кода заранее сгенерированного при помощи GCC.

Каждая инструкция процессора разбивается на микрооперации, эти микрооперации реализованы на языке C. Микрооперации выбираются так, чтобы их количество было много меньше количества всех возможных комбинаций инструкций и операндов процессора.

Программа входящая в QEMU --- dyngen использует объектные файлы с микроинструкциями и генерирует на их основе динамический генератор кода, именно он используется во время выполнения программы для трансляции. \cite{qemu}

\subsubsection{Оптимизации используемые в QEMU }

Главной идеей является возможность передачи константных параметров микрооперациям. Для этого GCC генерирует специальный код (?) для каждых константных параметров (я щяс умру..).

Например:\\
		movl\_T0\_r1 \# T0 = r1\\
		addl\_T0\_im -16 \# T0 = T0 - 16\\
		movl\_r1\_T0 \# r1 = T0\\

Таким образом уменьшается количество необходимых микроопераций, так как можно реализовать операции загрузки всех необходимых регистров во временные регистры и проводить операции именно с ними. Эти регистры обычно хранятся в регистрах хоста (например T0, T1 и T2 хранились бы в rax, rbx, rcx на x86).

Важным условием является наличие только одной точки выхода из микрооперации, действительно, наличие нескольких точек выхода сделает невозможным простое (без вызова процедуры) соединение микроинструкций.

Трансляция кода происходит блоками, блоком является часть кода в которой состояние процессора можно определить на этапе трансляции. QEMU транслирует весь такой блок до условного jump или иной инструкции изменяющей состояние процессора.

QEMU (в 2005, проверить что щяс (потому что типа хотели динамически выделять временные регистры и экономить время, о как!)) использует статическое выделение регистров. Каждый регистр эмулируемого процессора отображается на регистр хоста или на участок памяти.

ОПТИМИЗАЦИЯ ИФОВ! Главным замедляющим фактором при эмуляции является эмуляция условных операций (регистр eflags на x86). QEMU не обновляет условные регистры после каждой операции, вместо этого хранится один операнд (CC\_SRC), результат (CC\_DST) и тип операции (CC\_OP). Например для 32-битного сложения $R = A + B$ хранится будут:\\
\texttt{
CC\_SRC=A\\
CC\_DST=R\\
CC\_OP=CC\_OP\_ADDL
}

Этих данных достаточно чтобы восстановить $B$ и нужные флаги, такие как ZF, SF, CF, OF.

После трансляции блока так же проверяется, используются ли переменные CC\_SRC, CC\_DST, CC\_OP, если они не используются то им ничего не следует присваивать на стадии выполнения.

После выполнения блока QEMU ищет следующий блок в хэш-таблице, если он уже транслирован, начинается его исполнение, иначе запускается процесс трансляции. Если значение PC (program counter) известно заранее, QEMU может модифицировать блоки так, чтобы необходимый блок запускался сразу после предыдущего.

Для ускорения трансляции адресов используется кэш. (поболее)

\subsection{bruh}

Список:

\begin{itemize}[leftmargin=1.6\parindent]
	\item[---] первое;
	\item[---] второе;
	\item[---] пятое;
	\item[---] десятое.
\end{itemize}

Формула:

\begin{equation}
c^2 = a^2 + b^2
\end{equation}

Ссылаемся на рисунок \ref{fig:a1}. Информация из источника \cite{golang}.

\begin{figure}[hbtp]
	\centering
	\includegraphics[width=\textwidth]{img/golang.png}
	\caption{Пример рисунка}
	\label{fig:a1}
\end{figure}

\begin{code}
	\captionof{listing}{Пример кода}
	\label{code:1}
	\inputminted
	[
	frame=single,
	framerule=0.5pt,
	framesep=20pt,
	fontsize=\small,
	tabsize=4,
	linenos,
	numbersep=5pt,
	xleftmargin=10pt,
	]
	{text}
	{code/main.go}
\end{code}

\pagebreak